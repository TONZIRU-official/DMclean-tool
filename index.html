<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Portal Gravity - Hand Physics</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
    canvas { position: absolute; width: 100vw; height: 100vh; object-fit: cover; }
    #video_canvas { transform: scaleX(-1); opacity: 0.3; } /* カメラ映像は薄く背景に */
    #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #fff; z-index: 10; pointer-events: none; }
    #msg { font-size: 20px; background: rgba(0,0,0,0.6); display: inline-block; padding: 10px 20px; border-radius: 30px; border: 1px solid #0ff; }
  </style>
</head>
<body>

<div id="ui">
  <div id="msg">手をかざして吸い寄せ、指を閉じると爆発！</div>
</div>

<video id="input_video" style="display:none;"></video>
<canvas id="video_canvas"></canvas>
<canvas id="game_canvas"></canvas>

<script>
  const videoElement = document.getElementById('input_video');
  const vCanvas = document.getElementById('video_canvas');
  const vCtx = vCanvas.getContext('2d');
  const gCanvas = document.getElementById('game_canvas');

  // --- Matter.js セットアップ ---
  const { Engine, Render, Runner, Bodies, Composite, Body, Vector } = Matter;
  const engine = Engine.create();
  engine.world.gravity.y = 0; // 無重力状態に設定

  const render = Render.create({
    canvas: gCanvas,
    engine: engine,
    options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
  });

  // 壁の作成（画面外にいかないように）
  const walls = [
    Bodies.rectangle(window.innerWidth/2, -50, window.innerWidth, 100, { isStatic: true }),
    Bodies.rectangle(window.innerWidth/2, window.innerHeight+50, window.innerWidth, 100, { isStatic: true }),
    Bodies.rectangle(-50, window.innerHeight/2, 100, window.innerHeight, { isStatic: true }),
    Bodies.rectangle(window.innerWidth+50, window.innerHeight/2, 100, window.innerHeight, { isStatic: true })
  ];
  Composite.add(engine.world, walls);

  // 物体（キューブ）をたくさん生成
  const boxes = [];
  for(let i=0; i<80; i++) {
    const b = Bodies.rectangle(Math.random()*window.innerWidth, Math.random()*window.innerHeight, 25, 25, {
      frictionAir: 0.05,
      render: { fillStyle: `hsl(${Math.random()*360}, 80%, 60%)` }
    });
    boxes.push(b);
  }
  Composite.add(engine.world, boxes);

  Render.run(render);
  Runner.run(Runner.create(), engine);

  // --- MediaPipe ハンドトラッキング ---
  function onResults(results) {
    vCanvas.width = window.innerWidth;
    vCanvas.height = window.innerHeight;
    vCtx.save();
    vCtx.clearRect(0, 0, vCanvas.width, vCanvas.height);
    vCtx.drawImage(results.image, 0, 0, vCanvas.width, vCanvas.height);
    vCtx.restore();

    if (results.multiHandLandmarks) {
      for (const landmarks of results.multiHandLandmarks) {
        // カメラが反転しているので座標を補正
        const x = (1 - landmarks[8].x) * window.innerWidth;
        const y = landmarks[8].y * window.innerHeight;

        // 親指と人差し指の距離を計算（つまみ判定）
        const thumb = landmarks[4];
        const index = landmarks[8];
        const distance = Math.hypot(thumb.x - index.x, thumb.y - index.y);
        const isPinching = distance < 0.08;

        boxes.forEach(box => {
          const forceVector = Vector.sub({x, y}, box.position);
          const dist = Vector.magnitude(forceVector);
          const unitVec = Vector.normalise(forceVector);

          if (isPinching) {
            // 弾き飛ばす（斥力）
            if (dist < 300) {
              Body.applyForce(box, box.position, Vector.mult(unitVec, -0.05));
            }
          } else {
            // 吸い寄せる（引力）
            if (dist < 500) {
              Body.applyForce(box, box.position, Vector.mult(unitVec, 0.001 * (dist/10)));
            }
          }
        });

        // 手の位置にエフェクト描画
        vCtx.beginPath();
        vCtx.arc(landmarks[8].x * vCanvas.width, y, isPinching ? 60 : 30, 0, Math.PI*2);
        vCtx.strokeStyle = isPinching ? '#f0f' : '#0ff';
        vCtx.lineWidth = 5;
        vCtx.stroke();
      }
    }
  }

  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 1280, height: 720
  });
  camera.start();

  window.addEventListener('resize', () => {
    render.canvas.width = window.innerWidth;
    render.canvas.height = window.innerHeight;
  });
</script>
</body>
</html>
