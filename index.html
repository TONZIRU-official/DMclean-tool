<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Finger Balance - Fast Response</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #input_video { position: fixed; width: 1px; height: 1px; opacity: 0; } /* 処理軽減のため隠す */
        #view_video { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: 0; }
        canvas { position: fixed; top: 0; left: 0; z-index: 1; pointer-events: none; }
        #ui { position: fixed; top: 20px; left: 20px; color: #fff; z-index: 2; text-shadow: 0 0 10px #000; }
        .score-num { font-size: 48px; color: #0ff; }
    </style>
</head>
<body>
    <video id="input_video"></video>
    <video id="view_video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div>SCORE</div>
        <div class="score-num" id="score">0</div>
        <p>指を素早く動かしてキャッチ！</p>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const viewVideo = document.getElementById('view_video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        let width, height;
        let fingerX = 0, fingerY = 0, lastFingerX = 0;
        let score = 0;

        let pole = { x: 0, y: -200, angle: 0, angVel: 0, isCaught: false };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            resetPole();
        }
        window.addEventListener('resize', resize);
        resize();

        function resetPole() {
            pole.x = Math.random() * (width - 100) + 50;
            pole.y = -100;
            pole.angle = (Math.random() - 0.5) * 1;
            pole.angVel = (Math.random() - 0.5) * 0.05;
            pole.isCaught = false;
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, // 0にすると精度を少し下げて速度を爆速にする
            minDetectionConfidence: 0.5 
        });

        hands.onResults(results => {
            if (results.multiHandLandmarks?.length > 0) {
                const tip = results.multiHandLandmarks[0][8];
                // 指の座標を滑らかにするための簡易的な補間
                const targetX = (1 - tip.x) * width;
                const targetY = tip.y * height;
                fingerX += (targetX - fingerX) * 0.8; 
                fingerY += (targetY - fingerY) * 0.8;
            }
        });

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, height: 480 // 低解像度にして認識を高速化
        });
        camera.start();

        // 自分の姿を見せる用のカメラ設定
        navigator.mediaDevices.getUserMedia({video: true}).then(stream => {
            viewVideo.srcObject = stream;
        });

        function update() {
            ctx.clearRect(0, 0, width, height);

            if (!pole.isCaught) {
                pole.y += 6; // 落下速度
                pole.angle += pole.angVel;
                
                // 当たり判定を少し広く（40px -> 60px）
                if (Math.hypot(fingerX - pole.x, fingerY - pole.y) < 60) {
                    pole.isCaught = true;
                    score++;
                    scoreDisplay.innerText = score;
                }
                if (pole.y > height + 100) resetPole();
            } else {
                // 物理演算の感度を調整
                pole.angVel += Math.sin(pole.angle) * 0.012;
                pole.angVel -= (fingerX - lastFingerX) * 0.003; // 反応を鋭く
                pole.angVel *= 0.97;
                pole.angle += pole.angVel;
                pole.x = fingerX;
                pole.y = fingerY;

                if (Math.abs(pole.angle) > 1.5) {
                    pole.isCaught = false;
                    setTimeout(resetPole, 1000);
                }
            }

            // 描画
            ctx.save();
            ctx.translate(pole.x, pole.y);
            ctx.rotate(pole.angle);
            ctx.shadowBlur = 15;
            ctx.shadowColor = pole.isCaught ? '#0f0' : '#f00';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -250);
            ctx.stroke();
            ctx.restore();

            // 指先のガイド
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fingerX, fingerY, 20, 0, Math.PI * 2);
            ctx.stroke();

            lastFingerX = fingerX;
            requestAnimationFrame(update);
        }
        update();
    </script>
</body>
</html>
