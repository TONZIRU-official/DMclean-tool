<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NEON STRING - Hand Tracking Action</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
    canvas { position: absolute; transform: scaleX(-1); width: 100vw; height: 100vh; object-fit: cover; }
    #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #0ff; z-index: 10; pointer-events: none; text-shadow: 0 0 15px #0ff; }
    #score { font-size: 50px; font-weight: bold; }
    .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(circle, transparent 20%, rgba(0,20,40,0.4) 100%); }
  </style>
</head>
<body>

<div id="ui">
  <div id="score">0</div>
  <div>両手の人差し指の「糸」で敵を切れ！</div>
</div>
<div class="overlay"></div>

<video id="input_video" style="display:none;"></video>
<canvas id="output_canvas"></canvas>

<script>
  const videoElement = document.getElementById('input_video');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const scoreElement = document.getElementById('score');

  let score = 0;
  let targets = [];
  let particles = [];
  let frameCount = 0;

  function spawnTarget() {
    const side = Math.random() > 0.5 ? 0 : window.innerWidth;
    targets.push({
      x: side,
      y: Math.random() * window.innerHeight,
      vx: (side === 0 ? 1 : -1) * (3 + Math.random() * 5),
      vy: (Math.random() - 0.5) * 2,
      size: 25,
      hit: false
    });
  }

  // 線と点の距離を計算する関数（当たり判定用）
  function distToSegment(p, v, w) {
    const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
    if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
  }

  function onResults(results) {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    let fingerPoints = [];

    if (results.multiHandLandmarks) {
      for (const landmarks of results.multiHandLandmarks) {
        // 人差し指の先を取得
        const x = landmarks[8].x * canvasElement.width;
        const y = landmarks[8].y * canvasElement.height;
        fingerPoints.push({x, y});
        
        // 指先の光
        canvasCtx.shadowBlur = 20;
        canvasCtx.shadowColor = "#0ff";
        canvasCtx.fillStyle = "#fff";
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 10, 0, Math.PI*2);
        canvasCtx.fill();
      }
    }

    // 両手がある時、糸を張る
    if (fingerPoints.length >= 2) {
      const p1 = fingerPoints[0];
      const p2 = fingerPoints[1];

      canvasCtx.shadowBlur = 15;
      canvasCtx.shadowColor = "#0ff";
      canvasCtx.strokeStyle = "#fff";
      canvasCtx.lineWidth = 4;
      canvasCtx.beginPath();
      canvasCtx.moveTo(p1.x, p1.y);
      canvasCtx.lineTo(p2.x, p2.y);
      canvasCtx.stroke();

      // 糸の当たり判定
      targets.forEach(t => {
        if (!t.hit && distToSegment(t, p1, p2) < t.size) {
          t.hit = true;
          score += 10;
          scoreElement.innerText = score;
          // 飛び散る火花
          for(let i=0; i<10; i++) {
            particles.push({x: t.x, y: t.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1});
          }
        }
      });
    }

    // ターゲットの更新
    if (frameCount % 40 === 0) spawnTarget();
    targets.forEach((t, i) => {
      t.x += t.vx;
      t.y += t.vy;
      
      canvasCtx.shadowBlur = t.hit ? 0 : 15;
      canvasCtx.fillStyle = t.hit ? "transparent" : "#f0f";
      canvasCtx.beginPath();
      canvasCtx.arc(t.x, t.y, t.size, 0, Math.PI*2);
      canvasCtx.fill();

      if (t.x < -50 || t.x > window.innerWidth + 50) targets.splice(i, 1);
    });

    // 火花の更新
    particles.forEach((p, i) => {
      p.x += p.vx; p.y += p.vy; p.life -= 0.05;
      canvasCtx.fillStyle = `rgba(0, 255, 255, ${p.life})`;
      canvasCtx.fillRect(p.x, p.y, 4, 4);
      if (p.life <= 0) particles.splice(i, 1);
    });

    frameCount++;
    canvasCtx.restore();
  }

  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6});
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 1280, height: 720
  });
  camera.start();
</script>
</body>
</html>
